
\documentclass[utf8]{article}
\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{fullpage}

\setlength\parindent{24pt}

\begin{document}
\begin{titlepage}
    

\author{Andrius Ezerskis \& MoÃ¯ra Vanderslagmolen \& Hasan Yildirim}
\title{Rapport d'OS}

\maketitle
\end{titlepage}

\section{Introduction}
\par
Il y a peu de temps, notre universitÃ© a dÃ©cidÃ© qu'il Ã©tait temps de changer notre base de donnÃ©es des Ã©tudiants afin d'amÃ©liorer l'accessibilitÃ© et le confort du systÃ¨me, ce qui permettra de fournir plus d'informations et une meilleure entrÃ©e Ã  nos camarades Ã©tudiants. La base de donnÃ©es prÃ©cÃ©dente ne rÃ©pondait plus aux besoins depuis que le nombre d'Ã©tudiants a considÃ©rablement augmentÃ© ces derniÃ¨res annÃ©es. Il Ã©tait donc nÃ©cessaire que notre universitÃ© s'occupe de ce problÃ¨me de croissance de la base de donnÃ©es.
Nous avons demandÃ© ce projet pour gÃ©rer la crÃ©ation d'une nouvelle base de donnÃ©es. Notre groupe est composÃ© de 3 Ã©tudiants qui ont jouÃ© des rÃ´les diffÃ©rents dans ce projet mais en coopÃ©ration. L'ancienne base de donnÃ©es donnait beaucoup d'Ã©checs. Les rÃ©pÃ©titions de noms, les informations manquantes sur les Ã©tudiants, ou les comptes supprimÃ©s Ã©taient les quelques exemples parmi tant d'autres survenus pendant l'utilisation active de la base de donnÃ©es. Notre projet a Ã©tÃ© divisÃ© en 8 parties diffÃ©rentes. Les parties suivantes sont les parties de notre projet.
\par


\section{Stockage de la base de donnÃ©es}
\indent{}
\par
Afin de stocker les donnÃ©es de milliers d'Ã©tudiants, plusieurs choix se sont offerts Ã  nous. 
Tout d'abord, nous avons utilisÃ© std::map, comparable Ã  un dictionnaire en python, dont les
clÃ©s ont Ã©tÃ© l'identifiant de l'Ã©lÃ¨ve et les valeurs la struct student. Seulement, cela
prenait beaucoup de place en mÃ©moire et nous avons donc dÃ©laissÃ© l'idÃ©e. Nous avons donc dÃ©cidÃ© de faire un tableau.
\par
BigTouristHere
#7988

lil belugi. â€” Aujourdâ€™hui Ã  22:20
latex?
big belugoooo. â€” Aujourdâ€™hui Ã  22:21
j'ai pull et mtn je dois commit ? tf
j'ai rien changÃ©
Image
lil belugi. â€” Aujourdâ€™hui Ã  22:21
oui c'est normal
ta fait un merge
big belugoooo. â€” Aujourdâ€™hui Ã  22:21
ahhh
dcp je commit ou je discard changes
lil belugi. â€” Aujourdâ€™hui Ã  22:21
andrius
big belugoooo. â€” Aujourdâ€™hui Ã  22:21
normalement ya un message d'erreur c'est pour Ã§a que je comprenais pas ğŸ˜‚
lil belugi. â€” Aujourdâ€™hui Ã  22:22
commit jcrois c enes qui a fait
par pur hasard
j'ai regardÃ© comment on envoyait un msg d'un child Ã  un parent
big belugoooo. â€” Aujourdâ€™hui Ã  22:22
ui ?
lil belugi. â€” Aujourdâ€™hui Ã  22:22
jsuis tombÃ©e sur du javascript
big belugoooo. â€” Aujourdâ€™hui Ã  22:22
ğŸ˜‚
lil belugi. â€” Aujourdâ€™hui Ã  22:23
tout a l'air... si simple
big belugoooo. â€” Aujourdâ€™hui Ã  22:23
montre
lil belugi. â€” Aujourdâ€™hui Ã  22:24
PTN pardon
j'ai des petits soucis avec les screen
MMM JE VAIS DEVENIR FOLLE
Image
lil belugi. â€” Aujourdâ€™hui Ã  22:25
en gros qd je copie une image
il me copie son path
ğŸ˜
c'est un chouilla relou
big belugoooo. â€” Aujourdâ€™hui Ã  22:27
c'est l'Ã©quivalent de tes 100 lignes de code nn ?
genre avec les pipes etc ğŸ˜‚
lil belugi. â€” Aujourdâ€™hui Ã  22:27
tg
je t'emmerdeğŸ˜­ ğŸ˜­
AHHH
I hate c++
big belugoooo. â€” Aujourdâ€™hui Ã  22:30
ğŸ˜‚
jsuis en train de retaper le latex
big belugoooo. â€” Aujourdâ€™hui Ã  22:34
mais naaan
c'est mignon C++
j'ai encore oubliÃ© comment compiler le latex
lil belugi. â€” Aujourdâ€™hui Ã  22:37
xddd
juste open pdf
att j'ai un peu changÃ© quelques trucs dans le rapport
big belugoooo. â€” Aujourdâ€™hui Ã  22:38
moi aussi ğŸ™‚
lil belugi. â€” Aujourdâ€™hui Ã  22:38
je sais la facon dont j'Ã©crit est giga moche mais jveux juste pas oublier les idÃ©es que j'avais
lil belugi. â€” Aujourdâ€™hui Ã  22:38
fuck
att
ta les trucs de enes toi nan?
big belugoooo. â€” Aujourdâ€™hui Ã  22:39
idk
lil belugi. â€” Aujourdâ€™hui Ã  22:39
moi j'avais pas pull jvoulais pas avoir de merge
je te passe ce que jai changÃ©
\section{Checker l'identifiant}
\indent{}
\par
Pour voir si l'identifiant est dÃ©jÃ  prÃ©sent dans la base de donnÃ©es, nous avons pensÃ© Ã  mettre chaque Ã©tudiant
dans son emplacement "correspondant" dans le tableau (Ã©tudiant id=500 va Ã  l'emplacement db[500]). La recherche par id et le delete auraient Ã©tÃ© rapides, et on 
aurait pu rapidement savoir si un Ã©tudiant est dÃ©jÃ  prÃ©sent dans le tableau ou non.
Seulement, si l'utilisateur introduit un id trÃ¨s grand, le stockage de la data base sera trÃ¨s grand, pour un seul Ã©tudiant.
Nous avons donc essayÃ© d'implÃ©menter une boucle for, qui vÃ©rifiait si l'id de l'Ã©tudiant n'Ã©tait pas encore prÃ©sent en itÃ©rant dans toute la base de donnÃ©es.
Cela prenait beaucoup trop de temps. Nous avons donc dÃ©cidÃ© d'avoir un tableau triÃ© d'Ã©tudiants. Pour cela, lorsque nous ajoutons un Ã©tudiant,
nous vÃ©rifions si l'Ã©tudiant Ã  l'emplacement du tableau -1 est plus petit que lui. Si il est plus petit que lui, nous l'ajoutons juste derriÃ¨re. Sinon, 
nous dÃ©crÃ©mentons la variable au fur et Ã  mesure, jusqu'Ã  ce que l'Ã©tudiant aie un Ã©tudiant + petit que lui. Lorsqu'il trouve cet Ã©tudiant, il s'insÃ¨re juste derriÃ¨re lui
et dÃ©cale toute la database afin de s'insÃ©rer en plein milieu.
Lors de l'update, nous avons remarquÃ© que l'utilisateur maladroit pouvait par exemple Ã©crire update fname=Mario set id=88.
Pour s'assurer que cela n'arrive pas, nous vÃ©rifions si l'id n'est pas dÃ©jÃ  prÃ©sent dans la database dans la fonction update.
Nous copions l'Ã©tudiant duquel on veut changer l'id, nous changeons l'id du nouvel Ã©tudiant et nous l'ajoutons Ã  la database. Si l'id 
n'est dÃ©jÃ  prÃ©sent, nous ajoutons le nouvel Ã©tudiant grÃ¢ce Ã  la fonction db add, qui trie les Ã©tudiants en les ajoutant.
Nous arrÃªtons immÃ©diatement la boucle dans si l'id est dÃ©jÃ  prÃ©sent ou non pour des soucis de performance(deux Ã©tudiants ne peuvent pas avoir le mÃªme id, 
donc tous les Ã©tudiants s'appelant Mario ne peuvent pas avoir le nouvel id). 
\par
\section{Fin d'une query}

\indent{}
\par
Pour signaler la fin d'une query, nous avons implÃ©mentÃ© une message queue grÃ¢ce Ã  une pipe. Lorsqu'on envoie 
une query Ã  un processus, nous incrÃ©mentons une variable globale operation in progress qui indique le nombre d'opÃ©rations en cours.
Lorsque qu'un processus termine sa query, il Ã©crit dans sa pipe "SUCCESS". Le processus principal va lire cette pipe et va dÃ©crÃ©menter
la variable globale au fur et Ã  mesure. Le pipe est non-bloquant, ce qui permet au processus principal de continuer
mÃªme si il ne lit rien dans la pipe. Lors d'une transaction, on limite operation in progress Ã  1.

\section{Gestion de signaux}
\indent{}
\par
Plusieurs choix se sont offerts Ã  nous afin de terminer un programme. Nous avons d'abord pensÃ© Ã  4 pipes qui indiquent au programme principal 
la fin d'une requÃªte, mais ce n'Ã©tait pas optimal.
Nous avons repris la message queue qui traite les query, et dans 
cette message queue, le processus principal Ã©crit un message, "kill". Les processus enfants le liront aprÃ¨s avoir terminÃ© leur requÃªtes,
et le kill arrÃªtera la boucle et exit le programme.
Seulement, lorsque le processus enfant se termine, le processus parent n'est pas au courant de la mort de l'enfant. Nous avons donc eu 
beaucoup de processus zombies. Pour rÃ©gler ce souci, nous avons tout simplement ignorÃ© le signal SIGCHLD.


\section{Checker l'identifiant}
\indent{}
\par
Pour voir si l'identifiant est dÃ©jÃ  prÃ©sent dans la base de donnÃ©es, nous avons pensÃ© Ã  mettre chaque Ã©tudiant
dans son emplacement "correspondant" dans le tableau (Ã©tudiant id=500 va Ã  l'emplacement db[500]). La recherche par id et le delete auraient Ã©tÃ© rapides, et on 
aurait pu rapidement savoir si un Ã©tudiant est dÃ©jÃ  prÃ©sent dans le tableau ou non.
Seulement, si l'utilisateur introduit un id trÃ¨s grand, le stockage de la data base sera trÃ¨s grand, pour un seul Ã©tudiant.
Nous avons donc essayÃ© d'implÃ©menter une boucle for, qui vÃ©rifiait si l'id de l'Ã©tudiant n'Ã©tait pas encore prÃ©sent en itÃ©rant dans toute la base de donnÃ©es.
Cela prenait beaucoup trop de temps. Nous avons donc dÃ©cidÃ© d'avoir un tableau triÃ© d'Ã©tudiants. Pour cela, lorsque nous ajoutons un Ã©tudiant,
nous vÃ©rifions si l'Ã©tudiant Ã  l'emplacement du tableau -1 est plus petit que lui. Si il est plus petit que lui, nous l'ajoutons juste derriÃ¨re. Sinon, 
nous dÃ©crÃ©mentons la variable au fur et Ã  mesure, jusqu'Ã  ce que l'Ã©tudiant aie un Ã©tudiant + petit que lui. Lorsqu'il trouve cet Ã©tudiant, il s'insÃ¨re juste derriÃ¨re lui
et dÃ©cale toute la database afin de s'insÃ©rer en plein milieu.
Lors de l'update, nous avons remarquÃ© que l'utilisateur maladroit pouvait par exemple Ã©crire update fname=Mario set id=88.
Pour s'assurer que cela n'arrive pas, nous vÃ©rifions si l'id n'est pas dÃ©jÃ  prÃ©sent dans la database dans la fonction update.
Nous copions l'Ã©tudiant duquel on veut changer l'id, nous changeons l'id du nouvel Ã©tudiant et nous l'ajoutons Ã  la database. Si l'id 
n'est dÃ©jÃ  prÃ©sent, nous ajoutons le nouvel Ã©tudiant grÃ¢ce Ã  la fonction db add, qui trie les Ã©tudiants en les ajoutant.
Nous arrÃªtons immÃ©diatement la boucle dans si l'id est dÃ©jÃ  prÃ©sent ou non pour des soucis de performance(deux Ã©tudiants ne peuvent pas avoir le mÃªme id, 
donc tous les Ã©tudiants s'appelant Mario ne peuvent pas avoir le nouvel id). 
\par
\section{Fin d'une query}

\indent{}
\par
Pour signaler la fin d'une query, nous avons implÃ©mentÃ© une message queue grÃ¢ce Ã  une pipe. Lorsqu'on envoie 
une query Ã  un processus, nous incrÃ©mentons une variable globale operation in progress qui indique le nombre d'opÃ©rations en cours.
Lorsque qu'un processus termine sa query, il Ã©crit dans sa pipe "SUCCESS". Le processus principal va lire cette pipe et va dÃ©crÃ©menter
la variable globale au fur et Ã  mesure. Le pipe est non-bloquant, ce qui permet au processus principal de continuer
mÃªme si il ne lit rien dans la pipe. Lors d'une transaction, on limite operation in progress Ã  1.

\section{Gestion de signaux}
\indent{}
\par
Plusieurs choix se sont offerts Ã  nous afin de terminer un programme. Nous avons d'abord pensÃ© Ã  4 pipes qui indiquent au programme principal 
la fin d'une requÃªte, mais ce n'Ã©tait pas optimal.
Nous avons repris la message queue qui traite les query, et dans 
cette message queue, le processus principal Ã©crit un message, "kill". Les processus enfants le liront aprÃ¨s avoir terminÃ© leur requÃªtes,
et le kill arrÃªtera la boucle et exit le programme.
Seulement, lorsque le processus enfant se termine, le processus parent n'est pas au courant de la mort de l'enfant. Nous avons donc eu 
beaucoup de processus zombies. Pour rÃ©gler ce souci, nous avons tout simplement ignorÃ© le signal SIGCHLD.


\section{Classes}
\indent{}
\par
Nous avons mis la database\_t et le query\_result\_t dans une classe, afin de rendre le code plus lisible. Par consÃ©quent,
nous avons implÃ©mentÃ© un constructeur dans query\_result\_t, au lieu du query\_result\_init, pour que le code
crÃ©e directement le query\_result\_t, sans devoir appeller l'initialisation Ã  chaque crÃ©ation d'objet.
Dans query result t, nous avons aussi ajoutÃ© log query, pour pouvoir mettre les attributs en privÃ©s.
Nous n'avons pas mis student\_t en classe, parce que les attributs d'un student sont souvent accÃ©dÃ©s par la classe query result t.
et nous n'aurions donc pas su mettre les attributs en privÃ©s.


\section{AmÃ©liorations possibles}
    \subsection{std::map}
    \indent{}
\par
    Nous avions comme idÃ©e de stocker, dans un structure de donnÃ©es std::map (Ã©quivalent d'un dictionnaire en Python), les identifiants des Ã©tudiants en clÃ©s ainsi que leur indice de position dans la base de donnÃ©es en valeurs de ces clÃ©s. \newline
    Selon nous, cela aurait permis de faciliter et d'amÃ©liorer l'efficacitÃ© de la vÃ©rification de si un Ã©tudiant est dÃ©jÃ  dans la base de donnÃ©es ou non. \newline En effet, lors de l'ajout d'un Ã©tudiant, nous aurions juste Ã  vÃ©rifier si l'identifiant est prÃ©sent dans le map pour Ã©viter d'avoir des doublons dans la base de donnÃ©es.
    \subsection{Threads}
    \indent{}
    \par
    Au lieu d'utiliser des processus, nous aurions pu utiliser des threads. Seulement, si le processus main crashe,
    alors tous les threads crashent aussi. L'avantage des processus est leur indÃ©pendance, ce qui les rend plus stable que des threads.\\
\section{Process vs Thread}
\par
Tout d'abord, nous allons dÃ©finir ce qu'est un processus et un thread, et finalement les avantages des processus.\\

Donc, un processus est l'exÃ©cution d'un programme qui permet d'effectuer les actions appropriÃ©es spÃ©cifiÃ©es dans un programme. Il peut Ãªtre dÃ©fini comme une unitÃ© d'exÃ©cution oÃ¹ s'exÃ©cute un programme. Le systÃ¨me d'exploitation vous aide Ã  crÃ©er, planifier et terminer les processus utilisÃ©s par l'unitÃ© centrale. Les autres processus crÃ©Ã©s par le processus principal sont appelÃ©s processus enfants.

Ensuite, un thread est une unitÃ© d'exÃ©cution qui fait partie d'un processus. Un processus peut avoir plusieurs threads, tous exÃ©cutÃ©s en mÃªme temps. Il s'agit d'une unitÃ© d'exÃ©cution dans la programmation concurrente. Un thread est lÃ©ger et peut Ãªtre gÃ©rÃ© indÃ©pendamment par un planificateur. Il vous aide Ã  amÃ©liorer les performances de l'application en utilisant le parallÃ©lisme.

Nous avons utilisÃ© des processus pour rÃ©aliser notre projet, comme prÃ©cisÃ© dans les consignes. Les avantages des processus qui nous ont aidÃ©s Ã  rÃ©aliser ce projet sont les suivants :\\
\begin{itemize}
    \item La crÃ©ation de chaque processus nÃ©cessite des appels systÃ¨me distincts pour chaque processus.\\
    \item Il s'agit d'une entitÃ© d'exÃ©cution isolÃ©e qui ne partage pas les donnÃ©es et les informations.\\
    \item Les processus utilisent le mÃ©canisme IPC(Inter-Process Communication) pour la communication qui augmente considÃ©rablement le nombre d'appels systÃ¨me.\\
    \item La gestion des processus nÃ©cessite plus d'appels systÃ¨me.\\
    \item Un processus a sa pile, son tas de mÃ©moire avec la mÃ©moire, et sa carte de donnÃ©es.\\
\end{itemize}
\par
\end{document}
