
\documentclass[utf8]{article}
\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{fullpage}
\nocite{*}


\setlength\parindent{24pt}

\begin{document}
\begin{titlepage}
    

\author{Andrius Ezerskis \& Moïra Vanderslagmolen \& Milan Skaleric}
\title{Rapport d'OS}

\maketitle
\end{titlepage}

\section{Introduction}
\par
\section{Choix d'implémentation et difficultés rencontrées}
\subsection{Multi-threading}
Nous avons limité le nombre de clients à 50.

\subsection{Redirection du stdout}

\section{Synchronisation}
— une explication détaillée des mécanismes de synchronisations utilisés
\section{Processus vs Threads}
— une comparaison détaillée entre l’utilisation des processus et des threads (projets 1 et 2),
avec une discussion sur les avantages et inconvénients des deux méthodes,
Le processus est indépendant, et donc même si le processus principal se crashe, les processus enfants peuvent continuer d'exécuter des tâches.

La gestion en mémoire partagée est beaucoup plus simple avec des threads.
Les threads sont plus rapides que les processus à la création et à la destruction.
\section{Améliorations}
— des propositions d’améliorations relatives au fonctionnement et aux performances (non
aux fonctionnalités)
Pour améliorer la rapidité de notre programme, nous avons eu plusieurs idées.

La création et destruction de threads est assez coûteuse, nous pourrions donc laisser un thread gérer un certains nombres de clients, par exemple 5 clients.
Au lieu d'écrire dans la requête dans un socket et d'écrire le résultat de ce même socket, nous pourrions écrire dans un fichier, pour ne pas être limité en caractères.

Tout d'abord
\end{document}
