
\documentclass[utf8]{article}
\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{fullpage}

\setlength\parindent{24pt}

\begin{document}
\begin{titlepage}
    

\author{Andrius Ezerskis \& Moïra Vanderslagmolen \& Hasan Yildirim}
\title{Rapport d'OS}

\maketitle
\end{titlepage}

\section{Introduction}

\section{Stockage de la base de données}
\indent{}
\par
Afin de stocker les données de milliers d'étudiants, plusieurs choix se sont offerts à nous. 
Tout d'abord, nous avons utilisé std::map, comparable à un dictionnaire en python, dont les
clés ont été l'identifiant de l'élève et les valeurs la struct student. Seulement, cela
prenait beaucoup de place en mémoire et nous avons donc délaissé l'idée. Nous avons donc décidé de faire un tableau.
\par
\section{Checker l'identifiant}
\indent{}
\par
Pour voir si l'identifiant est déjà présent dans la base de données, nous avons pensé à mettre chaque étudiant
dans son emplacement "correspondant" dans le tableau (étudiant id=500 va à l'emplacement db[500]). La recherche par id et le delete auraient été rapides, et on 
aurait pu rapidement savoir si un étudiant est déjà présent dans le tableau ou non.
Seulement, si l'utilisateur introduit un id très grand, le stockage de la data base sera très grand, pour un seul étudiant.
Nous avons donc essayé d'implémenter une boucle for, qui vérifiait si l'id de l'étudiant n'était pas encore présent en itérant dans toute la base de données.
Cela prenait beaucoup trop de temps. Nous avons donc décidé d'avoir un tableau trié d'étudiants. Pour cela, lorsque nous ajoutons un étudiant,
nous vérifions si l'étudiant à l'emplacement du tableau -1 est plus petit que lui. Si il est plus petit que lui, nous l'ajoutons juste derrière. Sinon, 
nous décrémentons la variable au fur et à mesure, jusqu'à ce que l'étudiant aie un étudiant + petit que lui. Lorsqu'il trouve cet étudiant, il s'insère juste derrière lui
et décale toute la database afin de s'insérer en plein milieu.
\par
\section{Fin d'une query}
\indent{}
\par
Pour signaler la fin d'une query, nous avons implémenté une message queue grâce à une pipe. Lorsqu'on envoie 
une query à un processus, nous incrémentons une variable globale OperationInProgress qui indique le nombre d'opérations en cours.
Lorsque qu'un processus termine sa query, il écrit dans sa pipe "SUCCESS". Le processus principal va lire cette pipe et va décrémenter
la variable globale au fur et à mesure. Le pipe est non-bloquant, ce qui permet au processus principal de continuer
même si il ne lit rien dans la pipe. Lors d'une transaction, on limite OperationInProgress à 1.

\section{Gestion de signaux}
\indent{}
\par
Plusieurs choix se sont offerts à nous afin de terminer un programme. Nous avons d'abord pensé à 4 pipes qui indiquent au programme principal 
la fin d'une requête, mais ce n'était pas optimal.
Nous avons repris la message queue qui traite les query, et dans 
cette message queue, le processus principal écrit un message, "kill". Les processus enfants le liront après avoir terminé leur requêtes,
et le kill arrêtera la boucle et exit le programme.


\section{Classes}
\indent{}
\par
Nous avons mis la database\_t et le query\_result\_t dans une classe, afin de rendre le code plus lisible. Par conséquent,
nous avons implémenté un constructeur dans query\_result\_t, au lieu du query\_result\_init, pour que le code
crée directement le query\_result\_t, sans devoir appeller l'initialisation à chaque création d'objet.
Dans query result t, nous avons aussi ajouté log query, pour pouvoir mettre les attributs en privés.
Nous n'avons pas mis student\_t en classe, parce que les attributs d'un student sont souvent accédés par la classe query result t.
et nous n'aurions donc pas su mettre les attributs en privés.


\section{Améliorations possibles}
    \subsection{std::map}
    \indent{}
\par
    Nous avions comme idée de stocker, dans un structure de données std::map (équivalent d'un dictionnaire en Python), les identifiants des étudiants en clés ainsi que leur indice de position dans la base de données en valeurs de ces clés. \newline
    Selon nous, cela aurait permis de faciliter et d'améliorer l'efficacité de la vérification de si un étudiant est déjà dans la base de données ou non. \newline En effet, lors de l'ajout d'un étudiant, nous aurions juste à vérifier si l'identifiant est présent dans le map pour éviter d'avoir des doublons dans la base de données.
    \subsection{Threads}
    \indent{}
    \par
    Au lieu d'utiliser des processus, nous aurions pu utiliser des threads. Seulement, si le processus main crashe,
    alors tous les threads crashent aussi. L'avantage des processus est leur indépendance, ce qui les rend plus stable que des threads.

\end{document}
